import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id 'java'
    id 'io.qameta.allure' version '2.9.3'
    id 'com.google.cloud.tools.jib' version '3.3.1'
}

//def getGitHash = { ->
//    def stdout = new ByteArrayOutputStream()
//    exec {
//        commandLine "git", "rev-parse", "--short", "HEAD"
//        standardOutput = stdout
//    }
//    return stdout.toString().trim()
//}

group 'net.class101'
//version getGitHash()

repositories {
    mavenCentral()
}

ext {
    allureVersion = '2.16.1'
    junitVersion = '5.8.1'
}

sourceCompatibility = '17'
targetCompatibility = '17'

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

dependencies {
    implementation("com.fasterxml.jackson.core:jackson-databind:2.13.4.2")
    implementation ('com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.13.4')


    testImplementation('com.codeborne:selenide:5.25.0')
    testImplementation("io.qameta.allure:allure-selenide:${allureVersion}")
    testImplementation('org.slf4j:slf4j-simple:1.7.30')

    testImplementation("org.junit.jupiter:junit-jupiter-api:${junitVersion}")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:${junitVersion}")
    testImplementation("org.testcontainers:testcontainers:1.17.5")
    testImplementation("org.testcontainers:junit-jupiter:1.17.5")
}

test {
    useJUnitPlatform()
}

allure {
    autoconfigure = true
    version = "${allureVersion}"

    useJUnit5 {
        version = "${allureVersion}"
    }
}

jib {
    from {
        image = 'openjdk:17'
    }

    to {
        image = '212011163676.dkr.ecr.ap-northeast-2.amazonaws.com/class101-ui-test'
        project.afterEvaluate {
            tags = [version]
        }
    }

    container {
        creationTime = 'USE_CURRENT_TIMESTAMP'
        jvmFlags = []
    }
}

tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}


task libs(type: Sync) {
    from configurations.testRuntimeClasspath
    into "$buildDir/lib"
}

classes.dependsOn libs

[compileJava, compileTestJava]*.options.collect {options -> options.encoding = 'UTF-8'}
[compileJava, compileTestJava]*.options.collect {options -> options.debug = true}

tasks.withType(Test).all { testTask ->
    testTask.systemProperties = [
            'file.encoding': 'UTF-8',
            'BUILD_URL': System.getenv()['BUILD_URL']
    ]
    testTask.testLogging.showStandardStreams = true
    testTask.outputs.upToDateWhen { false }
}
